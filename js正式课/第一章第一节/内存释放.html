<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>内存释放</title>
</head>
<body>
<script>
    /*
    * JS内存
    * 堆内存：存放引用数据类型的
    * 对象类型、函数类型再创建时浏览器分配了内存，如果他的引用地址被赋值给变量，则该变量被占用；
    * 堆内存释放：将引用对象变量设置为Null，即引用数据类型地址不被变量使用或者占用；谷歌浏览器会定时自动扫描页面的变量，将不被占用的引用类型变量做垃圾收回，IE和FIrefox，需要手动将占用的变量设置为Null
    * var obj1={nick:"lsmife",age:12};
    * obj1=obj2;
    * obj1=null;
    * obj2=null;
    * 如图：内存释放
    * 栈内存：
    * 全局作用域,页面关闭时才会作用域销毁，栈内存释放
    * 私有作用域（函数执行的时候才会有），函数私有作用域中代码由上至下执行完毕时作用域销毁栈内存释放
    * JS没有块儿级作用域for(){} if(){} switch(){}
    * 栈内存销毁，栈内存中的堆内存也被销毁；也就是函数执行完毕后，引用类型内容也不存在了；
    * 栈内存销毁例外：当前作用域中的变量被当前作用域之外的内容占用，那么当前作用就不能被销毁
    * 1、函数返回一个引用数据类型的值，被外部变量接受
    * function fn(){
    *   var num=100;
    *   return function(){
    *
    *   }
    * }
    * var f=fn(); //fn()作用域不销毁，fn中存在一个引用类型的值，被外部占用了
    * 栈内存中的堆内存地址被外部变量占用了，那么堆内存不能销毁，栈内存也不能被销毁
    * 2、函数内部的一个引用类型的变量地址被外部引用类型变量的属性占用
    * var obj=document.getElementById('#div1')
    *  ~function(){
    *       obj.onclick=function(){
    *           console.log('ok')
    *       }
    *  }()
    *
    * 3、函数返回一个引用数据类型的值（函数），不利己销毁，函数紧接着执行,执行后浏览器空闲时销毁
    * var num=200;
    * function fn(){
    * var num=100;
    *      return function(){
    *          console.log(num);
    *      }
    * }
    * 综合练习
    * 一、
    * fn()(); // -> 100
    * function fn(){
    *   var i=10;
    *   return function(n){
    *       console.log(n+(++i));
    *   }
    * }
    * var f=fn();
    * f(10); // ->21
    * f(20); // ->32
    * fn()(10); // ->21
    * fn()(20); // ->31
    * 图：预解释2
    * 二、
    * function fn(i){
    *     return function(n){
    *         console.log(n+ i++);
    *     }
    * }
    * var f=fn(13);
    * f(12); // ->12+13
    * f(14); // ->14+14
    * fn(15)(12); // ->15+12
    * fn(16)(13); // ->16+13
    * 三、
    * 思考题：选项卡
     */
</script>
</body>
</html>